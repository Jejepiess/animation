<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Mortain Spider!!!</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;

        window.addEventListener("mousemove", (event) => {
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        // Generate random dots (prey)
        const dots = Array.from({ length: 100 }, () => ({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height
        }));

        class Tentacle {
            constructor() {
                this.numSegments = 12;
                this.segmentLength = 25;
                this.segments = Array.from({ length: this.numSegments }, () => ({ x: 0, y: 0 }));
                this.targetDot = null;
                this.holdingTime = 0;
                this.maxHoldTime = Math.random() * 60 + 30;
                this.attached = false;
            }

            getClosestDot() {
                let closest = null;
                let minDistance = Infinity;
                dots.forEach(dot => {
                    let distance = Math.hypot(this.segments[this.numSegments - 1].x - dot.x, this.segments[this.numSegments - 1].y - dot.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = dot;
                    }
                });
                return closest;
            }

            update(baseX, baseY) {
                this.segments[0].x = baseX;
                this.segments[0].y = baseY;

                this.holdingTime++;

                // If no target dot or it's time to switch, find a new one
                if (!this.targetDot || this.holdingTime > this.maxHoldTime) {
                    this.targetDot = this.getClosestDot();
                    this.holdingTime = 0;
                    this.maxHoldTime = Math.random() * 60 + 30;
                    this.attached = false;
                }

                if (this.targetDot) {
                    let last = this.segments[this.numSegments - 1];

                    if (!this.attached) {
                        last.x += (this.targetDot.x - last.x) * 0.2;
                        last.y += (this.targetDot.y - last.y) * 0.2;

                        // Latch onto the dot when close enough
                        if (Math.hypot(last.x - this.targetDot.x, last.y - this.targetDot.y) < 5) {
                            last.x = this.targetDot.x;
                            last.y = this.targetDot.y;
                            this.attached = true;
                        }
                    }
                }

                // Chain the segments together
                for (let i = 1; i < this.numSegments; i++) {
                    let prev = this.segments[i - 1];
                    let seg = this.segments[i];

                    let dx = seg.x - prev.x;
                    let dy = seg.y - prev.y;
                    let angle = Math.atan2(dy, dx);

                    seg.x = prev.x + Math.cos(angle) * this.segmentLength;
                    seg.y = prev.y + Math.sin(angle) * this.segmentLength;
                }
            }

            draw() {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                ctx.moveTo(this.segments[0].x, this.segments[0].y);
                for (let i = 1; i < this.numSegments; i++) {
                    ctx.lineTo(this.segments[i].x, this.segments[i].y);
                }
                ctx.stroke();
            }
        }

        class Spider {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.speed = 0.07;
                this.tentacles = Array.from({ length: 20 }, () => new Tentacle());
            }

            move() {
                this.x += (mouseX - this.x) * this.speed;
                this.y += (mouseY - this.y) * this.speed;
            }

            draw() {
                this.move();
                ctx.beginPath();
                ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();

                this.tentacles.forEach((tentacle) => {
                    tentacle.update(this.x, this.y);
                    tentacle.draw();
                });
            }
        }

        function drawDots() {
            ctx.fillStyle = "rgba(255, 255, 0, 0.9)";
            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        let spider = new Spider();

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawDots();
            spider.draw();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

